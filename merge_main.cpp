/***********************************************************
  *File Name: 
  *Description: 
  *Author: Chen Xi
  *Email: chenxi1@genomics.cn
  *Create Time: 2022-01-24 15:31:38
  *Edit History: 
***********************************************************/

#include <ctype.h>
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>

#include "mp.h"
#include "str.h"
#include "utils.h"
#include "image.h"

using namespace cv;
using namespace std;

typedef struct {
	str_t * gem;
	str_t * tif;

	int col[2];
	int row[2];
	int col_range;
	int row_range;
	int row_rev;
	int col_rev;
	int xy_tr;

	int part_idx;
	int col_min_os;
	int row_min_os;
	int col_max_os;
	int row_max_os;
} gem_t;

static void
piece_init2 (gem_t * p)
{
	p->gem = str_init ();
	p->tif = str_init ();
}

MP_DEF (gem, gem_t);

static int
usage (void)
{
	fprintf (stderr, "\n");
	fprintf (stderr, "Usage:   gem_ext merge [options] <list> <rows> <cols>\n");
	fprintf (stderr, "Options: -o   STR   Output directory of output files (optional, default: './')\n");
	fprintf (stderr, "         -s   STR   Sample name of output files (optional, default: 'sample')\n");
	fprintf (stderr, "         -e         Keep extra info in gem files (optional)\n");
	fprintf (stderr, "         -d   INT   Pixel distance between the center of nearby pieces (optional, need >= 100, default: 100)\n");
	fprintf (stderr, "\n");
	fprintf (stderr, "Notes: 1. <list> format:\n");
	fprintf (stderr, "          sample.1.gem rev_row rev_col xy_exchange\n");
	fprintf (stderr, "          sample.2.gem rev_row rev_col xy_exchange\n");
	fprintf (stderr, "          ...\n");
	fprintf (stderr, "          rev_row: flip, set to 1; keep original, set to 0\n");
	fprintf (stderr, "          rev_col: flip, set to 1; keep original, set to 0\n");
	fprintf (stderr, "          xy_exchange: exchange x-y coordinates, set to 1; keep original, set to 0\n");
	fprintf (stderr, "          Please use the gem file names generated by 'gem_ext part'\n");
	fprintf (stderr, "          Please DO NOT change the gem file names\n");
	fprintf (stderr, "\n");
	fprintf (stderr, "       2. [tif.list] format:\n");
	fprintf (stderr, "          sample.1.part.tif\n");
	fprintf (stderr, "          sample.2.part.tif\n");
	fprintf (stderr, "          ...\n");
	fprintf (stderr, "          ssDNA pieces that match the part-gem files\n");
	fprintf (stderr, "          Please use the tif file names generated by 'gem_ext part'\n");
	fprintf (stderr, "          Please DO NOT change the tif file names\n");
	fprintf (stderr, "\n");

	return 1;
}

static int
load_info_file (const char * file, mp_t(gem) * infos)
{
	char gem[4096];
	char tif[4096];
	char line[4096];
	char * ch;
	int has_tif = 0;
	FILE * in;
	int ret;
	int n_dots;
	int n_items;
	gem_t * piece;

	in = ckopen (file, "r");

	fgets (line, 4096, in);
	piece = mp_alloc (gem, infos);
	n_items = sscanf (line, "%s %d %d %d %s %d %d %d %d", gem,
			&piece->row_rev, &piece->col_rev, &piece->xy_tr, tif,
			&piece->col_min_os, &piece->row_min_os,
			&piece->col_max_os, &piece->row_max_os);
	str_assign (piece->gem, gem);
	assert (n_items==9 || n_items==4);

	if (n_items==9 && *tif!='*') {
		str_assign (piece->tif, tif);
		has_tif = 1;
	} else if (n_items == 4) {
		piece->col_min_os = 0;
		piece->row_min_os = 0;
		piece->col_max_os = 0;
		piece->row_max_os = 0;
	}

	//for (ch=gem+strlen(gem),n_dots=0; ch>=gem; --ch)
	//	if (*ch=='.' && ++n_dots==3)
	//		break;
	//assert (n_dots==3 && ch>gem);
	//piece->part_idx = atoi (ch+1);

	while (fgets(line,4096,in)) {
		piece = mp_alloc (gem, infos);
		ret = sscanf (line, "%s %d %d %d %s %d %d %d %d", gem,
				&piece->row_rev, &piece->col_rev, &piece->xy_tr, tif,
				&piece->col_min_os, &piece->row_min_os,
				&piece->col_max_os, &piece->row_max_os);
		str_assign (piece->gem, gem);

		assert (ret == n_items);
		if (has_tif)
			str_assign (piece->tif, tif);
		if (n_items == 4) {
			piece->col_min_os = 0;
			piece->row_min_os = 0;
			piece->col_max_os = 0;
			piece->row_max_os = 0;
		}

		//for (ch=gem+strlen(gem),n_dots=0; ch>=gem; --ch)
		//	if (*ch=='.' && ++n_dots==3)
		//		break;
		//assert (n_dots==3 && ch>gem);
		//piece->part_idx = atoi (ch+1);
	}
	fclose (in);

	return has_tif;
}

int
merge_main (int argc, char * argv[])
{
	if (argc < 4)
		return usage ();

	char line[4096];
	char gene[4096];
	char file[4096];
	char buff[4096];
	char * gem_list;
	char * spl_name;
	char * out_dir;
	char * ch;
	int i, j, k;
	int copt;
	int x, y;
	int val;
	int n_dots;
	int n_rows;
	int n_cols;
	int row;
	int col;
	int xmin, xmax;
	int ymin, ymax;
	int col_sep;
	int row_sep;
	int tmp;
	int has_tif;
	int keep_extra;
	int pdist;
	Mat img;
	gzFile gem_in;
	gzFile out;
	gzFile out2;
	gem_t * piece;
	mp_t(gem) * list;

	gem_list = ALLOC_LINE;
	spl_name = ALLOC_LINE;
	out_dir = ALLOC_LINE;

	pdist = 100;
	keep_extra = 0;
	while ((copt = getopt(argc,argv,"o:s:ed:")) != -1) {
		if (copt == 'o') {
			strcpy (out_dir, optarg);
		} else if (copt == 's') {
			strcpy (spl_name, optarg);
		} else if (copt == 'e') {
			keep_extra = 1;
		} else if (copt == 'd') {
			if ((pdist = atoi(optarg)) < 100) {
				fprintf (stderr, "Error: pixel distance must >= 100!");
				return usage ();
			}
		} else {
			fprintf (stderr, "Error: Invalid parameter '-%c'!\n\n", copt);
			return usage ();
		}
	}

	if (optind >= argc) {
		fprintf (stderr, "fail to get gem list file!\n\n");
		return usage ();
	} else
		strcpy (gem_list, argv[optind++]);

	if (optind+1 >= argc) {
		fprintf (stderr, "fail to get nrows/ncols!\n\n");
		return usage ();
	} else {
		n_rows = atoi (argv[optind++]);
		n_cols = atoi (argv[optind++]);
		assert (n_rows>0 && n_cols>0);
	}

	if (!*out_dir)
		strcpy (out_dir, ".");

	if (!*spl_name)
		strcpy (spl_name, "sample");

	list = mp_init (gem, piece_init2);
	has_tif = load_info_file (gem_list, list);

	if (n_rows*n_cols < list->n) {
		fprintf (stderr, "'n_rows * n_cols' is less than number of gem files!\n\n");
		return usage ();
	}

	col_sep = INT_MIN;
	row_sep = INT_MIN;
	for (i=0; i<list->n; ++i) {
		piece = mp_at (gem, list, i);
		gem_in = ckgzopen (piece->gem->s, "r");
		xmin = ymin = INT_MAX;
		xmax = ymax = INT_MIN;
		while (gzgets(gem_in,line,4096))
			if (*line != '#')
				break;
		while (gzgets(gem_in,line,4096)) {
			sscanf (line, "%*s %d %d", &x, &y);

			if (x < xmin) xmin = x;
			if (x > xmax) xmax = x;
			if (y < ymin) ymin = y;
			if (y > ymax) ymax = y;
		}
		gzclose (gem_in);

		if (piece->xy_tr) {
			piece->col[0] = ymin;
			piece->col[1] = ymax + 1;
			piece->row[0] = xmin;
			piece->row[1] = xmax + 1;

		} else {
			piece->col[0] = xmin;
			piece->col[1] = xmax + 1;
			piece->row[0] = ymin;
			piece->row[1] = ymax + 1;
		}
		piece->row_range = piece->row[1] - piece->row[0] + piece->row_min_os - piece->row_max_os;
		piece->col_range = piece->col[1] - piece->col[0] + piece->col_min_os - piece->col_max_os;

		if (piece->col_range > col_sep)
			col_sep = piece->col_range;
		if (piece->row_range > row_sep)
			row_sep = piece->row_range;

		fprintf (stderr, "fixed gem range: %d-%d", piece->col_range, piece->row_range);
		if (has_tif) {
			xcv_imread (img, piece->tif->s);
			fprintf (stderr, "\tssDNA size: %d-%d",
				img.cols, img.rows);
		}
		fprintf (stderr, "\n");
	}

	fprintf (stderr, "col_sep: %d\trow_sep: %d\n", col_sep, row_sep);

	row_sep += pdist;
	col_sep += pdist;

	int prow_idx;
	int pcol_idx;
	int p_row_range;
	int p_col_range;
	int bcol, brow;
	int tot_row;
	int tot_col;
	int nret;
	int flag = 0;
	int n_column;

	tot_row = n_rows * row_sep;
	tot_col = n_cols * col_sep;

	sprintf (file, "%s/%s.merged.gem.gz", out_dir, spl_name);
	out = ckgzopen (file, "w");

	gzprintf (out, "#FileFormat=GEMv0.1\n");
	gzprintf (out, "#SortedBy=None\n");
	gzprintf (out, "#BinSize=1\n");
	gzprintf (out, "#OffsetX=0\n");
	gzprintf (out, "#OffsetY=0\n");

	for (i=0; i<list->n; ++i) {
		piece = mp_at (gem, list, i);
		prow_idx = i / n_cols;
		pcol_idx = i % n_cols;

		p_col_range = piece->col_range;
		p_row_range = piece->row_range;

		bcol = col_sep*pcol_idx + col_sep/2 - p_col_range/2;
		brow = row_sep*prow_idx + row_sep/2 - p_row_range/2;

		fprintf (stderr, "%d-%d\t%d-%d\n", col_sep*pcol_idx, row_sep*prow_idx, bcol, brow);

		sprintf (file, "%s/%s.p%d.gem.gz", out_dir, spl_name, i+1);
		out2 = ckgzopen (file, "w");
		gzprintf (out2, "#FileFormat=GEMv0.1\n");
		gzprintf (out2, "#SortedBy=None\n");
		gzprintf (out2, "#BinSize=1\n");
		gzprintf (out2, "#OffsetX=0\n");
		gzprintf (out2, "#OffsetY=0\n");
		gzprintf (out2, "geneID\tx\ty\tMIDCounts\n");

		gem_in = ckgzopen (piece->gem->s, "r");
		while (gzgets(gem_in,line,4096))
			if (*line != '#')
				break;

		if (!flag) {
			flag = 1;
			if (!keep_extra)
				gzprintf (out, "geneID\tx\ty\tMIDCounts\tSlice\n");
			else {
				int n_spaces = 0;
				for (ch=line; *ch!='\0'; ++ch)
					if (isspace(*ch) && (++n_spaces)==4)
						break;
				assert (n_spaces == 4);
				gzprintf (out, "geneID\tx\ty\tMIDCounts\tSlice%s", ch);

				n_column = 0;
				for (ch=line; *ch!='\0'; ++ch)
					if (isspace(*ch))
						++n_column;
			}
		}

		while (gzgets(gem_in,line,4096)) {
			nret = sscanf (line, "%s %d %d %d", gene, &x, &y, &val);
			if (piece->xy_tr)
				tmp=x, x=y, y=tmp;
			x = x - piece->col[0] + piece->col_min_os;
			y = y - piece->row[0] + piece->row_min_os;
			if (piece->col_rev)
				x = p_col_range - x;
			if (piece->row_rev)
				y = p_row_range - y;
			x = x + bcol;
			y = y + brow;

			if (!keep_extra) {
				gzprintf (out, "%s\t%d\t%d\t%d\t%d\n", gene, x, y, val, i+1);
				gzprintf (out2, "%s\t%d\t%d\t%d\n", gene, x, y, val);
			} else {
				int n_spaces = 0;
				for (ch=line; *ch!='\0'; ++ch)
					if (isspace(*ch) && (++n_spaces)==4)
						break;
				assert (n_spaces == 4);
				gzprintf (out, "%s\t%d\t%d\t%d\t%d\t%d%s", gene, x, y, val, i+1, ch);
				gzprintf (out2, "%s\t%d\t%d\t%d\t%d%s", gene, x, y, val, ch);
			}
		}
		//gzprintf (out2, "BLANKGENE\t%d\t%d\t1\n", col_sep*pcol_idx, row_sep*prow_idx);
		//gzprintf (out2, "BLANKGENE\t%d\t%d\t1\n", col_sep*(pcol_idx+1), row_sep*(prow_idx+1));
		gzclose (gem_in);
		gzclose (out2);
	}

	//gzprintf (out, "BLANKGENE\t%d\t%d\t1\n", 0, 0);
	//gzprintf (out, "BLANKGENE\t%d\t%d\t1\n", tot_col-1, tot_row-1);

	gzclose (out);

	if (!has_tif)
		return 0;

	Mat out_img = Mat::zeros (Size(tot_col,tot_row), CV_8UC3);
	for (k=0; k<list->n; ++k) {
		piece = mp_at (gem, list, k);
		prow_idx = k / n_cols;
		pcol_idx = k % n_cols;

		p_col_range = piece->col_range;
		p_row_range = piece->row_range;

		bcol = col_sep*pcol_idx + col_sep/2 - p_col_range/2;
		brow = row_sep*prow_idx + row_sep/2 - p_row_range/2;

		fprintf (stderr, "%d-%d\t%d-%d\n", col_sep*pcol_idx, row_sep*prow_idx, bcol, brow);

		xcv_imread (img, piece->tif->s);
		for (i=0; i<img.rows; ++i) {
			for (j=0; j<img.cols; ++j) {
				if (piece->xy_tr) {
					row = j;
					col = i;
				} else {
					row = i;
					col = j;
				}

				if (piece->col_rev)
					col = p_col_range - col;

				if (piece->row_rev)
					row = p_row_range - row;

				col = col + bcol;
				row = row + brow;
				out_img.at<Vec3b>(row,col) = img.at<Vec3b>(i,j);
			}
		}
	}

	sprintf (file, "%s/%s.merged.ssDNA.tif", out_dir, spl_name);
	imwrite (file, out_img);

	return 0;
}
